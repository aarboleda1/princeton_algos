[ x ] Linked List
[ x ] Dynamic array, implemented with a ring buffer (use a statically sized array underneath the hood)
[ x ] Hash set
[ x ] Hash map (with chaining)
[ x ] Binary heap (without decrease-key; know that Fibonacci heaps exist and know their guarantees)
[ x ] Binary search tree (doesn’t need to be self-balancing; know that self-balancing trees exist and know their guarantees)
[ ] Prefix tree (a.k.a. trie)
[ ] Suffix tree (don’t worry about compression, just build a dumb version; know that Ukkonen’s algorithm exists and learn its guarantees)
[ x ] An object-oriented adjacency list for graphs


[ x ] Binary search (implement it both iteratively and recursively)
[ x ] Randomized quicksort (pay extra attention to the partition subroutine, as it’s useful in a lot of places)
[ x ] Mergesort
[ x ] Breadth-first search in a graph
[ x ] Depth-first search in a graph (augment it to detect cycles)
[ ] Tree traversals (pre-order, in-order, post-order)
[ x ] Topological sort (using Tarjan’s algorithm)
[ ] Dijkstra’s algorithm (without decrease-key)
[ ] Longest common subsequence (using dynamic programming with matrices)
[ ] Knapsack problem (also dynamic programming)

Learn about heap sort, but don’t bother coding it. Know that it’s O(1) space but practically
very slow due to cache-inefficiency. Learn about quickselect and median-of-medians.
